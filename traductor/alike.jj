//*****************************************************************
// File:   alike.jj
// Author: Jorge Rodilla Esteve 845389 Enrique Martinez Casanova 839773
// Date:   marzo 2024
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;			// Esto hace que las comparaciones de tokens sea case-insensitive
	COMMON_TOKEN_ACTION = false;
}

PARSER_BEGIN(alike)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import java.util.*;
import lib.attributes.*;

public class alike {
	static SymbolTable st;
	static SemanticFunction sf;

	public static void main(String[] args) {
		st = new SymbolTable();
		sf = new SemanticFunction();

	   alike parser = null;
		try {
		    if (args.length == 0) {
			   parser = new alike(System.in);
			}
		    else {
			   parser = new alike(new java.io.FileInputStream(args[0]));
		    }
		   parser.Programa();
		   System.out.println("***** Análisis terminado *****");
	    }
	    catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	    }
	    catch (TokenMgrError e) {
		   System.err.println("LEXICAL ERROR: " + e.getMessage());
	    }
	    catch (ParseException e) {
		   System.err.println("PARSE ERROR: " + e.getMessage());
		}
	    catch (Exception e) {
			System.err.println("Finalizo traducción por detección de error no controlado: \n\t" + e.getMessage());
  		}
	}
}

PARSER_END(alike)

TOKEN : {
	<#tLETRA: (["a"-"z"])>
|	<#tDIGITO: ["0"-"9"]>
|	<#tCARACTER: (~["\t","\n","\r"])>
}

TOKEN : {
	<tBOOL: "boolean">
|	<tCHAR: "character">
|	<tINT: "integer">
|   <tASIG: ":=">
|   <tDISTINTO: "/=">
|   <tIGUAL: "=">
|   <tMAYOR: ">">
|   <tMENOR: "<">
|   <tMENORIGUAL: "<=">
|   <tMAYORIGUAL: ">=">
|   <tOPMAS: "+">
|   <tOPMENOS: "-">
|   <tOPMULT: "*">
|   <tOPDIV: "/">
|   <tBARRAB: "_">
|   <tIF: "if">
|   <tAND: "and">
|   <tOR: "or">
|   <tNOT: "not">
|   <tTHEN: "then">
|   <tELSE: "else">
|   <tELSIF: "elsif">
|   <tPC: ";">
|   <tPUNTOS: "..">
|   <tCOMA: ",">
|   <tWHILE: "while">
|   <tTRUE: "true">
|   <tFALSE: "false">
|   <tLOOP: "loop">
|   <tPROC: "procedure">
|   <tFUNC: "function">
|   <tIS: "is">
|	<tBEGIN: "begin">
|	<tEND: "end">	
|	<tOPMOD: "mod">
|	<tOF: "of">
|	<tREF: "ref">
|	<tAP: "(">
|	<tCP: ")">
|	<tAC: "[">
|	<tCC: "]">
|	<tARRAY: "array">
|	<tDOSP: ":">
|	<tRETURN: "return">
|	<tNULL: "null">
|	<tNUM: (<tDIGITO>)+>
|	<tID: (<tLETRA > | <tBARRAB>) (<tLETRA> | <tDIGITO> | <tBARRAB>)*>
|	<tSTRING: "\""(<tCARACTER>)*"\"">
|	<tCONSTCHAR: "\'"<tCARACTER>"\'">
}

SKIP :
{
	" "
|	"\t"
|	"\n"
|	"\r"
|	<tCOMMENT : "--" (<tCARACTER>)*>
}



void Programa() : 
{
}
{
	{
		st.insertBlock();
		/*
			int2char(int i)
			char2int(char c)
			skip_line
			put_line (sin parámetros)
		*/
	}
	Programa_completo()
	{st.removeBlock();}
	<EOF>
}



void Declaracion() : // Cada linea de declaracion dispara esta produccion
{
	ArrayList<String> array_nombres_variables;	// Estas variables son del mismo tipo
	Symbol tipo_variables;						// UN simbolo sin nombre
}
{
	{array_nombres_variables = new ArrayList<String>();}

	(Lista_IDS(array_nombres_variables) <tDOSP> tipo_variables = Tipos_variables())

	{sf.Declaracion(array_nombres_variables, tipo_variables, st);}
}



// Devuelve UN simbolo sin nombre del tipo correspondiente
Symbol Tipos_variables() :
{
	Symbol result;
}
{
	(result = Tipo_variable() | result = Tipo_array())
	{return result;}
}



// Array por referencia de IDs leidos
void Lista_IDS(ArrayList<String> array_nombres_variables) :
{
	Token t;
}
{
	t = <tID> {array_nombres_variables.add(t.image.toLowerCase());} (<tCOMA> Lista_IDS(array_nombres_variables))?
}



// Devuelve un puntero a símbolo sin nombre
Symbol Tipo_variable() :
{
	Token t;
	Symbol result = null;
}
{
	(t = <tBOOL> | t = <tINT> | t = <tCHAR>)
	{return sf.Tipo_variable(t, result);}
}



// Simbolo de tipo array sin nombre
Symbol Tipo_array() :
{
	Token indMin, indMax;
	Symbol tipo_base;
}
{
	<tARRAY> <tAP> indMin = <tNUM> <tPUNTOS> indMax = <tNUM> <tCP> <tOF> tipo_base = Tipo_variable()
	{return sf.Tipo_array(indMin, indMax, tipo_base);}
}



///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
Par Expresion() :
{
	Par tipo;
	Par tipo2 = new Par();
	boolean match2 = false;
}
{
	//tipo = Relacion() (((<tAND> | <tOR>) tipo2 = Relacion())+)?
	tipo = Relacion() ((<tAND> | <tOR>) tipo2 = Relacion()
	{
		tipo.segundo = false;
		if (tipo.primero != Symbol.Types.BOOL || tipo2.primero != Symbol.Types.BOOL) {
			System.out.println("ERROR: Se esperaba un tipo BOOL");
			tipo.primero = Symbol.Types.UNDEFINED;
		}
	})*
	{
		//System.out.println("Expresion: " + tipo.primero + " " + tipo.segundo);
		return tipo;
	}
}


Par Relacion() :
{
	Par tipo;
	Par tipo2 = new Par();
	Token op = null;
	boolean match = false;
}
{
	tipo = Expresion_simple() (op = Operador_relacional() tipo2 = Expresion_simple() {match=true;})?
	{
		if (match) {
			// Esto en una función
			tipo.segundo = false;
			String operador = op.image;
			if (operador.equals("<") || operador.equals(">") || operador.equals("<=") || operador.equals(">=")) {
				if (tipo.primero != Symbol.Types.INT || tipo2.primero != Symbol.Types.INT) {
					tipo.primero = Symbol.Types.UNDEFINED;
					System.out.println("ERROR: Se esperaba un tipo INT");
				}
				else tipo.primero = Symbol.Types.BOOL;
			}
			else if (tipo2.primero != Symbol.Types.ARRAY || tipo2.primero != Symbol.Types.FUNCTION ||
					tipo2.primero != Symbol.Types.PROCEDURE || tipo2.primero != Symbol.Types.STRING) {
				if (tipo.primero != tipo2.primero) {
					tipo.primero = Symbol.Types.UNDEFINED;
					System.out.println("ERROR: Se esperaba un tipo " + tipo.primero);
				}
				else tipo.primero = Symbol.Types.BOOL;
			}
			else {
				System.out.println("ERROR: Se esperaba un tipo INT/BOOL/CHAR");
			}
		}
		return tipo;
	}
}


Token Operador_relacional() :
{
	Token t;
}
{
    (t = <tIGUAL> | t = <tMENOR> | t = <tMAYOR> | t = <tMENORIGUAL> | t = <tMAYORIGUAL> | t = <tDISTINTO>)
	{
		return t;
	}
}


void Operador_multiplicativo() :
{
}
{
    <tOPMULT> | <tOPMOD> | <tOPDIV>
}


Par Expresion_simple() :
{
	Par tipo;
	Par tipo2 = new Par();
	boolean match1 = false;
}
{
	(<tOPMAS> {match1=false;} | <tOPMENOS> {match1=false;})?
	tipo = Termino() ((<tOPMAS> | <tOPMENOS>)  tipo2 = Termino()
	{
		tipo.segundo = false;
		if (tipo.primero != Symbol.Types.INT || tipo2.primero != Symbol.Types.INT) {
			System.out.println("ERROR: Se esperaba un tipo INT");
			tipo.primero = Symbol.Types.UNDEFINED;
		}
	})*
	{
		if (match1) tipo.segundo = false;
		return tipo;
	}
}


Par Termino() :
{
	Par tipo = new Par();
	Par tipo2 = new Par();
}
{
    tipo = Factor() (Operador_multiplicativo() tipo2 = Factor()
	{
		// Se ha hecho matching con un operador SÓLO numérico, la expresión ya NO es sólo una variable
		tipo.segundo = false;
		if (tipo.primero != Symbol.Types.INT || tipo2.primero != Symbol.Types.INT) {
			System.out.println("ERROR: Se esperaba un tipo INT");
			tipo.primero = Symbol.Types.UNDEFINED;
		}
	})*
	{
		return tipo;
	}
}


Par Factor() :
{
	Par tipo = new Par();
	Par tipo2 = new Par();
	boolean match = false;
}
{
	(tipo = Primario() | <tNOT> tipo2 = Primario() {match = true;})
	{
		if (match) {
			tipo.segundo = false;
			if (tipo2.primero != Symbol.Types.BOOL) {
				System.out.println("ERROR: Se esperaba un tipo BOOL");
				tipo.primero = Symbol.Types.UNDEFINED;
			}
			else tipo.primero = Symbol.Types.BOOL;
		}
		return tipo;
	}
}


Par Primario() :
{
	Token t;
	Par tipo = new Par();
	Symbol simbolo = null;
}
{
    (<tAP> tipo = Expresion() <tCP>
|	LOOKAHEAD(2) t = <tID> <tAP> Expresion() (<tCOMA> Expresion())* <tCP>
	{
		//////////////////////////////////////////////////
	}
|	t = <tID> {sf.Primario_ID(t, tipo, simbolo, st);}
|	t = <tNUM> {tipo.primero = Symbol.Types.INT;}
|	t = <tCONSTCHAR> {tipo.primero = Symbol.Types.CHAR;}
|	t = <tSTRING> {tipo.primero = Symbol.Types.STRING;}
|	t = <tTRUE> {tipo.primero = Symbol.Types.BOOL;}
|	t = <tFALSE> {tipo.primero = Symbol.Types.BOOL;})
	{return tipo;}
}
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////



void Asignacion() :
{
	Token id;
	Par tipo_asignacion;
}
{
	id = <tID> <tASIG> tipo_asignacion = Expresion()
	{sf.Asignacion(id.image, tipo_asignacion, st);}
}



void Instruccion_sin_return() :
{
	Token id;
	boolean llamada_funcion_simple = true;
}
{
	(LOOKAHEAD(2) Asignacion() // Asignacion a variable no array
	| LOOKAHEAD(2) id = <tID> (Instr_funcion_vector(id.image) {llamada_funcion_simple = false;})?
	{
		if (llamada_funcion_simple)
			sf.Instruccion(id.image, st);		// Llamada a función/procedimiento sin parámetros
	}
	| Instr_condicional_sin_return() | Instr_iterativa_sin_return()
	| <tNULL>) <tPC>
}



void Instruccion_con_return() :
{
	Token id;
	boolean llamada_funcion_simple = true;
}
{
	(LOOKAHEAD(2) Asignacion() // Asignacion a variable no array
	| LOOKAHEAD(2) id = <tID> (Instr_funcion_vector(id.image) {llamada_funcion_simple = false;})?
	{
		if (llamada_funcion_simple)
			sf.Instruccion(id.image, st);		// Llamada a función/procedimiento sin parámetros
	}
	| Instr_condicional_con_return() | Instr_iterativa_con_return()
	| <tNULL>
	| <tRETURN> Expresion()) <tPC>
}



void Instr_funcion_vector(String id) :
{
	Par tipo;
}
{
	<tAP> tipo = Expresion() Instr_funcion_vector_2(id, tipo)
}



void Instr_funcion_vector_2(String id, Par tipo) :
{
	Par parametro;
	ArrayList<Par> lista_argumentos = null;
}
{
	<tCP> Instr_funcion_vector_3(id, tipo)
	|	// Matching de las llamadas a funciones con más de un parámetro
	{
		// Se crea la lista de parámetros y se añade el primero ya leído
		lista_argumentos = new ArrayList<>();
		lista_argumentos.add(tipo);
	}
	(<tCOMA> parametro = Expresion()
	{
		// Se recogen los parámetros que se leen
		lista_argumentos.add(parametro);
	})+ <tCP>
	{
		// Llamada a método de comprobación de llamada a funciones con uno o más parámetros recibe (String id, ArrayList<Par> lista_argumentos)
		try {
			id = id.toLowerCase();
			sf.comprobar_funciones_especiales(id);

			Symbol simbolo_llamada = st.getSymbol(id);

			if (simbolo_llamada.type == Symbol.Types.FUNCTION || simbolo_llamada.type == Symbol.Types.PROCEDURE) {
				ArrayList<Symbol> lista_parametros;
				if (simbolo_llamada.type == Symbol.Types.FUNCTION) {
					SymbolFunction s = (SymbolFunction) simbolo_llamada;
					lista_parametros = s.parList;
				}
				else {
					SymbolProcedure s = (SymbolProcedure) simbolo_llamada;
					lista_parametros = s.parList;
				}
				if (lista_parametros.size() == lista_argumentos.size()) {
					for (int i = 0; i < lista_parametros.size(); i++) {
						Symbol simbolo_parametro = lista_parametros.get(i);
						Par argumento = lista_argumentos.get(i);
						if (argumento.primero != simbolo_parametro.type) {
							System.out.println("ERROR: Se esperaba un tipo " + simbolo_parametro.type + " en la llamada a " + id);
						}
						if (simbolo_parametro.parClass == Symbol.ParameterClass.REF && !argumento.segundo) {
							System.out.println("ERROR: El parámetro " + simbolo_parametro.name + " es un parámetro por referencia");
						}
						if (simbolo_parametro.type == Symbol.Types.ARRAY) {
							SymbolArray array_argumento = (SymbolArray) (st.getSymbol(argumento.tercero));
							SymbolArray array_parametro = (SymbolArray) (simbolo_parametro);
							if (array_argumento.minInd != array_parametro.minInd || array_argumento.maxInd != array_parametro.maxInd) {
								System.out.println("ERROR: Los índices del array parámetro " + simbolo_parametro.name + " no coinciden");
							}
							if (array_argumento.baseType != array_parametro.baseType) {
								System.out.println("ERROR: Los tipos base del array parámetro " + simbolo_parametro.name + " no coinciden");
							}
						}
					}
				}
				else {
					System.out.println("ERROR: El número de parámetros en la llamada a " + id + " no coinciden");
				}
			}
			else {
				System.out.println("ERROR: Se esperaba un tipo procedimiento/función");
			}
		}
		catch (SymbolNotFoundException s) {
			System.out.println("ERROR: El símbolo " + id + " no existe");
		}
		catch (SpecialFunctionFound g) {
			for (int i = 0; i < lista_argumentos.size(); i++) {
				Par argumento = lista_argumentos.get(i);
				if (id.equals("get") && (argumento.primero != Symbol.Types.INT && argumento.primero != Symbol.Types.CHAR)) {
					System.out.println("ERROR: Se esperaba un tipo INT/CHAR en la llamada a get");
				}
				else if ((id.equals("put") || id.equals("put_line")) && (argumento.primero != Symbol.Types.INT &&
						argumento.primero != Symbol.Types.BOOL && argumento.primero != Symbol.Types.CHAR && argumento.primero != Symbol.Types.STRING)) {
					System.out.println("ERROR: Se esperaba un tipo INT/BOOL/CHAR/STRING en la llamada a " + id);
				}
			}
		}
	}
}



void Instr_funcion_vector_3(String id, Par tipo_primera_expresion) :
{
	Par tipo_asignacion;
}
{
	// Matching de asignacion a componente de array "tipo_primera_expresion" es el tipo del índice
	<tASIG> tipo_asignacion = Expresion()
	{
		sf.Instr_funcion_vector_3(id, tipo_primera_expresion, tipo_asignacion, st);
	}

	| {}
	{
		ArrayList<Par> lista_argumentos = new ArrayList<>();
		lista_argumentos.add(tipo_primera_expresion);
		// Llamada a método compartido de llamadas a funciones
	}				
	// Matching de llamada a funcion con un solo parametro	///////////////////////////////////////////////////
}



void Programa_completo() :
{
}
{
	<tPROC> <tID> <tIS>
	(Declaracion() <tPC>)*
	(Procedimiento() | Funcion())*
	<tBEGIN>
	{System.out.println(st.toString());}
	(Instruccion_sin_return())+
	<tEND> <tPC>
}



// Devuelve un Symbol del tipo en cuestión, por valor o por referencia y sin nombre
Symbol Parametro_aux() :
{
	boolean por_referencia;
	Symbol tipo_parametro;
}
{
	({por_referencia = true;} <tREF> | {por_referencia = false;} {}) tipo_parametro = Tipos_variables() // Tipos_variables() devuelve UN symbol sin nombre de un tipo
	{
		if (por_referencia) {	// Se modifica el Symbol para indicar que es un parametro por referencia o por valor
			tipo_parametro.parClass = Symbol.ParameterClass.REF;
		}
		else {
			tipo_parametro.parClass = Symbol.ParameterClass.VAL;
		}
		return tipo_parametro;
	}
}



// Array por referencia con los símbolos leídos de parámetros
void Parametro(ArrayList<Symbol> lista_parametros) :
{
	ArrayList<String> array_nombres_variables = new ArrayList<>();
	Symbol tipo_parametros;
}
{
	Lista_IDS(array_nombres_variables) <tDOSP> tipo_parametros = Parametro_aux()
	{
		// Misma lógica que Declaracion(), se recoge un puntero a símbolo sin nombre y una lista de Strings,
		// se le asigna un nombre al puntero y se mete una copia en el array de simbolos
		for (String nombre_parametro : array_nombres_variables) {
			tipo_parametros.name = nombre_parametro;
			lista_parametros.add(tipo_parametros.clone());
		}
	}
}



// Similar a Declaracion(), inserta en la tabla de simbolos un array de símbolos (la lista de parametros) y lo retorna
ArrayList<Symbol> Parametros() :
{
	ArrayList<Symbol> lista_parametros = new ArrayList<>();
}
{
	(<tAP> Parametro(lista_parametros) (<tPC> Parametro(lista_parametros))* <tCP>)?
	{
		for (Symbol simbolo : lista_parametros) {
			try {st.insertSymbol(simbolo);}
			catch (AlreadyDefinedSymbolException a) {System.out.println("El simbolo " + simbolo.name + " ya esta definido (NO)");}
			catch (IndexArrayNotCorrect i) {System.out.println("Los indices del array " + simbolo.name + " no son correctos");}
		}
		return lista_parametros;
	}
}



void Procedimiento() :
{
	Token nombre_procedimiento;
	SymbolProcedure simbolo_procedimiento;
}
{
	<tPROC> nombre_procedimiento = <tID>
	// Antes de leer la lista de parametros se inserta el simbolo procedimiento y se crea el bloque de parametros y variables locales
	{
		// Se crea el simbolo procedimiento sin parametros, que van un nivel por debajo
		simbolo_procedimiento = new SymbolProcedure(nombre_procedimiento.image, new ArrayList<Symbol>());
		try {st.insertSymbol(simbolo_procedimiento);}
		catch (AlreadyDefinedSymbolException a) {System.out.println("El procedimiento " + nombre_procedimiento.image + " ya esta definido");}
		catch (IndexArrayNotCorrect i) {}	// Se sabe que el simbolo no es un array
		st.insertBlock();
	}
	simbolo_procedimiento.parList = Parametros() <tIS>	// Se asigna al simbolo del procedimiento la lista de parametros
	(Declaracion() <tPC>)*
	(Procedimiento() | Funcion())*
	<tBEGIN>
	(Instruccion_sin_return())+
	{st.removeBlock();}
	<tEND> <tPC>
}



// Igual a Procedimiento(), sólo cambia el return
void Funcion() :
{
	Token nombre_funcion;
	Symbol tipo_return;
	SymbolFunction simbolo_funcion;
}
{
	<tFUNC> nombre_funcion = <tID>
	{
		simbolo_funcion = new SymbolFunction(nombre_funcion.image, new ArrayList<Symbol>(), Symbol.Types.UNDEFINED);
		try {st.insertSymbol(simbolo_funcion);}
		catch (AlreadyDefinedSymbolException a) {System.out.println("La funcion " + nombre_funcion.image + " ya esta definida");}
		catch (IndexArrayNotCorrect i) {}
		st.insertBlock();
	}
	// Se asigna la lista de parámetros, se recoge el tipo que retorna la función y se asigna al simbolo función
	simbolo_funcion.parList = Parametros() <tRETURN> tipo_return = Tipo_variable() <tIS> {simbolo_funcion.returnType = tipo_return.type;}
	(Declaracion() <tPC>)*
	(Procedimiento() | Funcion())*
	<tBEGIN>
	(Instruccion_con_return())+
	{st.removeBlock();}
	<tEND> <tPC>
}



void Instr_iterativa_sin_return():
{
	Par tipo;
}
{
	<tWHILE> tipo = Expresion() <tLOOP>
	{
		if (tipo.primero != Symbol.Types.BOOL) {
			System.out.println("ERROR: Se esperaba una expresión booleana");
		}
	}
	(Instruccion_sin_return())+
	<tEND> <tLOOP>
}



void Instr_condicional_sin_return():
{
	Par tipo;
}
{
	<tIF> tipo = Expresion() <tTHEN>
	{
		if (tipo.primero != Symbol.Types.BOOL) {
			System.out.println("ERROR: Se esperaba una expresión booleana");
		}
	}
	(Instruccion_sin_return())+
	MasIF()
	<tEND> <tIF>
}



void MasIF():
{
	Par tipo;
}
{
	<tELSIF> tipo = Expresion() <tTHEN>
	{
		if (tipo.primero != Symbol.Types.BOOL) {
			System.out.println("ERROR: Se esperaba una expresión booleana");
		}
	}
	(Instruccion_sin_return())+
	MasIF()
	| <tELSE> (Instruccion_sin_return())+
	| {}
}



void Instr_iterativa_con_return():
{
	Par tipo;
}
{
	<tWHILE> tipo = Expresion() <tLOOP>
	{
		if (tipo.primero != Symbol.Types.BOOL) {
			System.out.println("ERROR: Se esperaba una expresión booleana");
		}
	}
	(Instruccion_con_return())+
	<tEND> <tLOOP>
}



void Instr_condicional_con_return():
{
	Par tipo;
}
{
	<tIF> tipo = Expresion() <tTHEN>
	{
		if (tipo.primero != Symbol.Types.BOOL) {
			System.out.println("ERROR: Se esperaba una expresión booleana");
		}
	}
	(Instruccion_con_return())+
	MasIF_return()
	<tEND> <tIF>
}



void MasIF_return():
{
	Par tipo;
}
{
	<tELSIF> tipo = Expresion() <tTHEN>
	{
		if (tipo.primero != Symbol.Types.BOOL) {
			System.out.println("ERROR: Se esperaba una expresión booleana");
		}
	}
	(Instruccion_con_return())+
	MasIF_return()
	| <tELSE> (Instruccion_con_return())+
	| {}
}
