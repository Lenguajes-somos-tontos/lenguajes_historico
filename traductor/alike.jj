//*****************************************************************
// File:   alike.jj
// Author: Jorge Rodilla Esteve 845389 Enrique Martinez Casanova 839773
// Date:   marzo 2024
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;			// Comparaciones de tokens case-insensitive
	COMMON_TOKEN_ACTION = false;
}

PARSER_BEGIN(alike)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import java.util.*;
import lib.attributes.*;

public class alike {
	static SymbolTable st;
	static SemanticFunction sf;

	static int codigo_estado;

	public static void main(String[] args) {
		st = new SymbolTable();
		sf = new SemanticFunction();
		codigo_estado = 0;

	   alike parser = null;
		try {
		    if (args.length == 0) {
			   parser = new alike(System.in);
			}
		    else {
			   args[0] += ".al";
			   parser = new alike(new java.io.FileInputStream(args[0]));
		    }
		   parser.Programa();
	    }
	    catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	    }
	    catch (TokenMgrError e) {
		   System.err.println("LEXICAL ERROR: " + e.getMessage());
	    }
	    catch (ParseException e) {
		   System.err.println("PARSE ERROR: " + e.getMessage());
		}
	    catch (Exception e) {
			System.err.println("Finalizo traducción por detección de error no controlado: \n\t" + e.getMessage());
  		}
		System.exit(codigo_estado);
	}
}

PARSER_END(alike)

TOKEN : {
	<#tLETRA: (["a"-"z"])>
|	<#tDIGITO: ["0"-"9"]>
|	<#tCARACTER: (~["\t","\n","\r"])>
}

TOKEN : {
	<tBOOL: "boolean">
|	<tCHAR: "character">
|	<tINT: "integer">
|   <tASIG: ":=">
|   <tDISTINTO: "/=">
|   <tIGUAL: "=">
|   <tMAYOR: ">">
|   <tMENOR: "<">
|   <tMENORIGUAL: "<=">
|   <tMAYORIGUAL: ">=">
|   <tOPMAS: "+">
|   <tOPMENOS: "-">
|   <tOPMULT: "*">
|   <tOPDIV: "/">
|   <tBARRAB: "_">
|   <tIF: "if">
|   <tAND: "and">
|   <tOR: "or">
|   <tNOT: "not">
|   <tTHEN: "then">
|   <tELSE: "else">
|   <tELSIF: "elsif">
|   <tPC: ";">
|   <tPUNTOS: "..">
|   <tCOMA: ",">
|   <tWHILE: "while">
|   <tTRUE: "true">
|   <tFALSE: "false">
|   <tLOOP: "loop">
|   <tPROC: "procedure">
|   <tFUNC: "function">
|   <tIS: "is">
|	<tBEGIN: "begin">
|	<tEND: "end">	
|	<tOPMOD: "mod">
|	<tOF: "of">
|	<tREF: "ref">
|	<tAP: "(">
|	<tCP: ")">
|	<tAC: "[">
|	<tCC: "]">
|	<tARRAY: "array">
|	<tDOSP: ":">
|	<tRETURN: "return">
|	<tNULL: "null">
|	<tEXIT: "exit">
|	<tNUM: (<tDIGITO>)+>
|	<tID: (<tLETRA > | <tBARRAB>) (<tLETRA> | <tDIGITO> | <tBARRAB>)*>
|	<tSTRING: "\""(<tCARACTER>)*"\"">
|	<tCONSTCHAR: "\'"<tCARACTER>"\'">
}

SKIP :
{
	" "
|	"\t"
|	"\n"
|	"\r"
|	<tCOMMENT : "--" (<tCARACTER>)*>
}


void Programa() : 
{
}
{
	{
		st.insertBlock();
		try {
			ArrayList<Symbol> lista_int =  new ArrayList<>();
			lista_int.add(new SymbolInt("i", Symbol.ParameterClass.VAL));
			st.insertSymbol(new SymbolFunction("int2char", lista_int, Symbol.Types.CHAR));
		
			ArrayList<Symbol> lista_char =  new ArrayList<>();
			lista_char.add(new SymbolChar("c", Symbol.ParameterClass.VAL));
			st.insertSymbol(new SymbolFunction("char2int", lista_char, Symbol.Types.INT));
		
			st.insertSymbol(new SymbolProcedure("skip_line", new ArrayList<Symbol>()));
			st.insertSymbol(new SymbolProcedure("put_line", new ArrayList<Symbol>()));
		}
		catch (AlreadyDefinedSymbolException a) {}
		catch (IndexArrayNotCorrect a) {}
	}
	Programa_completo()
	{st.removeBlock();}
	<EOF>
}


void Declaracion() : // Cada linea de declaracion dispara esta produccion
{
	ArrayList<String> array_nombres_variables;	// Estas variables son del mismo tipo
	Symbol tipo_variables;						// UN simbolo sin nombre
}
{
	{array_nombres_variables = new ArrayList<String>();}
	(Lista_IDS(array_nombres_variables) <tDOSP> tipo_variables = Tipos_variables())
	{sf.Declaracion(array_nombres_variables, tipo_variables, st);}
}


// Devuelve UN simbolo sin nombre del tipo correspondiente
Symbol Tipos_variables() :
{
	Symbol result;
}
{
	(result = Tipo_variable() | result = Tipo_array())
	{return result;}
}


// Array por referencia de IDs leidos
void Lista_IDS(ArrayList<String> array_nombres_variables) :
{
	Token t;
}
{
	t = <tID> {array_nombres_variables.add(t.image.toLowerCase());} (<tCOMA> Lista_IDS(array_nombres_variables))?
}


// Devuelve un puntero a símbolo sin nombre
Symbol Tipo_variable() :
{
	Token t;
	Symbol result = null;
}
{
	(t = <tBOOL> | t = <tINT> | t = <tCHAR>)
	{return sf.Tipo_variable(t, result);}
}


// Simbolo de tipo array sin nombre
Symbol Tipo_array() :
{
	Token indMin, indMax;
	Symbol tipo_base;
}
{
	<tARRAY> <tAP> indMin = <tNUM> <tPUNTOS> indMax = <tNUM> <tCP> <tOF> tipo_base = Tipo_variable()
	{return sf.Tipo_array(indMin, indMax, tipo_base);}
}


Par Expresion() :
{
	Par tipo;
	Par tipo2 = new Par();
	boolean match2 = false;
}
{
	tipo = Relacion() ((<tAND> | <tOR>) tipo2 = Relacion()
	{
		tipo.segundo = false;
		if (tipo.primero != Symbol.Types.BOOL || tipo2.primero != Symbol.Types.BOOL) {
			System.out.println("ERROR: Se esperaba un tipo BOOL");
			tipo.primero = Symbol.Types.UNDEFINED;
		}
	})*
	{return tipo;}
}


Par Relacion() :
{
	Par tipo;
	Par tipo2 = new Par();
	Token op = null;
	boolean match = false;
}
{
	tipo = Expresion_simple() (op = Operador_relacional() tipo2 = Expresion_simple() {match=true;})?
	{
		if (match) sf.verificar_relacion(op.image, tipo, tipo2);
		return tipo;
	}
}


Token Operador_relacional() :
{
	Token t;
}
{
    (t = <tIGUAL> | t = <tMENOR> | t = <tMAYOR> | t = <tMENORIGUAL> | t = <tMAYORIGUAL> | t = <tDISTINTO>)
	{return t;}
}


void Operador_multiplicativo() :
{
}
{
    <tOPMULT> | <tOPMOD> | <tOPDIV>
}


Par Expresion_simple() :
{
	Par tipo;
	Par tipo2 = new Par();
	boolean match1 = false;
}
{
	(<tOPMAS> {match1=false;} | <tOPMENOS> {match1=false;})?
	tipo = Termino() ((<tOPMAS> | <tOPMENOS>)  tipo2 = Termino()
	{sf.verificar_int(tipo, tipo2);})*
	{
		if (match1) tipo.segundo = false;
		return tipo;
	}
}


Par Termino() :
{
	Par tipo = new Par();
	Par tipo2 = new Par();
}
{
    tipo = Factor() (Operador_multiplicativo() tipo2 = Factor()
	{sf.verificar_int(tipo, tipo2);})*
	{return tipo;}
}


Par Factor() :
{
	Par tipo = new Par();
	Par tipo2 = new Par();
	boolean match = false;
}
{
	(tipo = Primario() | <tNOT> tipo2 = Primario() {match = true;})
	{
		if (match) {
			tipo.segundo = false;
			if (tipo2.primero != Symbol.Types.BOOL) {
				System.out.println("ERROR: Se esperaba un tipo BOOL");
				tipo.primero = Symbol.Types.UNDEFINED;
			}
			else tipo.primero = Symbol.Types.BOOL;
		}
		return tipo;
	}
}


Par Primario() :
{
	Token t;
	Par tipo = new Par();
	Symbol simbolo = null;
	ArrayList<Par> lista_argumentos = new ArrayList<>();
	Par argumento;
}
{
    (<tAP> tipo = Expresion() <tCP>
|	LOOKAHEAD(2) t = <tID> <tAP> argumento = Expresion() {lista_argumentos.add(argumento);}
	(<tCOMA> argumento = Expresion() {lista_argumentos.add(argumento);})* <tCP>
	{tipo = sf.verificar_expresion(t.image, lista_argumentos, st);}
|	t = <tID> {sf.Primario_ID(t, tipo, st);}
|	t = <tNUM> {tipo.primero = Symbol.Types.INT;}
|	t = <tCONSTCHAR> {tipo.primero = Symbol.Types.CHAR;}
|	t = <tSTRING> {tipo.primero = Symbol.Types.STRING;}
|	t = <tTRUE> {tipo.primero = Symbol.Types.BOOL;}
|	t = <tFALSE> {tipo.primero = Symbol.Types.BOOL;})
	{return tipo;}
}


void Asignacion() :
{
	Token id;
	Par tipo_asignacion;
}
{
	id = <tID> <tASIG> tipo_asignacion = Expresion()
	{sf.Asignacion(id.image, tipo_asignacion, st);}
}


void Instruccion_sin_return() :
{
	Token id;
	boolean llamada_funcion_simple = true;
}
{
	(LOOKAHEAD(2) Asignacion() // Asignacion a variable no array
	| LOOKAHEAD(2) id = <tID> (Instr_funcion_vector(id.image) {llamada_funcion_simple = false;})?
	{
		// Llamada a función/procedimiento sin parámetros
		if (llamada_funcion_simple) sf.verificar_llamada(id.image, new ArrayList<Par>(), st);
	}
	| Instr_condicional_sin_return() | Instr_iterativa_sin_return()
	| <tEXIT>
	| <tNULL>) <tPC>
}


boolean Instruccion_con_return(Symbol.Types tipo_a_retornar, int nivel) :
{
	Token id;
	boolean llamada_funcion_simple = true;
	Par tipo_return = null;
	boolean es_return = false;
	boolean return_valido = false;
}
{
	(LOOKAHEAD(2) Asignacion() // Asignacion a variable no array
	| LOOKAHEAD(2) id = <tID> (Instr_funcion_vector(id.image) {llamada_funcion_simple = false;})?
	{
		// Llamada a función/procedimiento sin parámetros
		if (llamada_funcion_simple) sf.verificar_llamada(id.image, new ArrayList<Par>(), st);
	}
	| Instr_condicional_con_return(tipo_a_retornar, nivel+1) | Instr_iterativa_con_return(tipo_a_retornar, nivel+1)
	| <tNULL>
	| <tEXIT>
	| <tRETURN> tipo_return = Expresion() {es_return = true;})
	<tPC>
	{
		if (es_return) {
			if (tipo_a_retornar != tipo_return.primero) {
				System.out.println("ERROR: Se esperaba un tipo " + tipo_a_retornar);
			}
			else if (nivel == 1) {
				return_valido = true;
			}
		}
		return return_valido;
	}
}


void Instr_funcion_vector(String id) :
{
	Par tipo;
}
{
	<tAP> tipo = Expresion() Instr_funcion_vector_2(id, tipo)
}


void Instr_funcion_vector_2(String id, Par tipo) :
{
	Par parametro;
	ArrayList<Par> lista_argumentos = null;
}
{
	<tCP> Instr_funcion_vector_3(id, tipo)
	|	// Matching de las llamadas a funciones con más de un parámetro
	{
		// Se crea la lista de parámetros y se añade el primero ya leído
		lista_argumentos = new ArrayList<>();
		lista_argumentos.add(tipo);
	}
	(<tCOMA> parametro = Expresion()
	{
		// Se recogen los parámetros que se leen
		lista_argumentos.add(parametro);
	})+ <tCP>
	{
		sf.verificar_llamada(id, lista_argumentos, st);
	}
}


void Instr_funcion_vector_3(String id, Par tipo_primera_expresion) :
{
	Par tipo_asignacion;
}
{
	// Matching de asignacion a componente de array "tipo_primera_expresion" es el tipo del índice
	<tASIG> tipo_asignacion = Expresion()
	{
		sf.Instr_funcion_vector_3(id, tipo_primera_expresion, tipo_asignacion, st);
	}

	| {}	// Matching de llamada a funcion con UN solo parametro
	{
		ArrayList<Par> lista_argumentos = new ArrayList<>();
		lista_argumentos.add(tipo_primera_expresion);
		sf.verificar_llamada(id, lista_argumentos, st);
	}
}


void Programa_completo() :
{
}
{
	<tPROC> <tID> <tIS>
	(Declaracion() <tPC>)*
	(Procedimiento() | Funcion())*
	<tBEGIN>
	(Instruccion_sin_return())+
	<tEND> <tPC>
}


// Devuelve un Symbol del tipo en cuestión, por valor o por referencia y sin nombre
Symbol Parametro_aux() :
{
	boolean por_referencia;
	Symbol tipo_parametro;
}
{
	({por_referencia = true;} <tREF> | {por_referencia = false;} {}) tipo_parametro = Tipos_variables() // Tipos_variables() devuelve UN symbol sin nombre de un tipo
	{
		if (por_referencia) tipo_parametro.parClass = Symbol.ParameterClass.REF;
		else tipo_parametro.parClass = Symbol.ParameterClass.VAL;
		return tipo_parametro;
	}
}


// Array por referencia con los símbolos leídos de parámetros
void Parametro(ArrayList<Symbol> lista_parametros) :
{
	ArrayList<String> array_nombres_variables = new ArrayList<>();
	Symbol tipo_parametros;
}
{
	Lista_IDS(array_nombres_variables) <tDOSP> tipo_parametros = Parametro_aux()
	{
		// Misma lógica que Declaracion(), se recoge un puntero a símbolo sin nombre y una lista de Strings,
		// se le asigna un nombre al puntero y se mete una copia en el array de simbolos
		for (String nombre_parametro : array_nombres_variables) {
			tipo_parametros.name = nombre_parametro.toLowerCase();
			lista_parametros.add(tipo_parametros.clone());
		}
	}
}


// Similar a Declaracion(), inserta en la tabla de simbolos un array de símbolos (la lista de parametros) y lo retorna
ArrayList<Symbol> Parametros() :
{
	ArrayList<Symbol> lista_parametros = new ArrayList<>();
}
{
	(<tAP> Parametro(lista_parametros) (<tPC> Parametro(lista_parametros))* <tCP>)?
	{
		for (Symbol simbolo : lista_parametros) {
			try {st.insertSymbol(simbolo);}
			catch (AlreadyDefinedSymbolException a) {System.out.println("El simbolo " + simbolo.name + " ya esta definido (NO)");}
			catch (IndexArrayNotCorrect i) {System.out.println("Los indices del array " + simbolo.name + " no son correctos");}
		}
		return lista_parametros;
	}
}


void Procedimiento() :
{
	Token nombre_procedimiento;
	SymbolProcedure simbolo_procedimiento;
}
{
	<tPROC> nombre_procedimiento = <tID>
	// Antes de leer la lista de parametros se inserta el simbolo procedimiento y se crea el bloque de parametros y variables locales
	{
		// Se crea el simbolo procedimiento sin parametros, que van un nivel por debajo
		simbolo_procedimiento = new SymbolProcedure(nombre_procedimiento.image.toLowerCase(), new ArrayList<Symbol>());
		try {st.insertSymbol(simbolo_procedimiento);}
		catch (AlreadyDefinedSymbolException a) {System.out.println("El procedimiento " + nombre_procedimiento.image + " ya esta definido");}
		catch (IndexArrayNotCorrect i) {}	// Se sabe que el simbolo no es un array
		st.insertBlock();
	}
	simbolo_procedimiento.parList = Parametros() <tIS>	// Se asigna al simbolo del procedimiento la lista de parametros
	(Declaracion() <tPC>)*
	(Procedimiento() | Funcion())*
	<tBEGIN>
	(Instruccion_sin_return())+
	<tEND> <tPC>
	{st.removeBlock();}
}


// Igual a Procedimiento(), sólo cambia el return
void Funcion() :
{
	Token nombre_funcion;
	Symbol tipo_return;
	SymbolFunction simbolo_funcion;
	boolean return_valido = false;
	boolean instruccion;
}
{
	<tFUNC> nombre_funcion = <tID>
	{
		simbolo_funcion = new SymbolFunction(nombre_funcion.image, new ArrayList<Symbol>(), Symbol.Types.UNDEFINED);
		try {st.insertSymbol(simbolo_funcion);}
		catch (AlreadyDefinedSymbolException a) {System.out.println("La funcion " + nombre_funcion.image.toLowerCase() + " ya esta definida");}
		catch (IndexArrayNotCorrect i) {}
		st.insertBlock();
	}
	// Se asigna la lista de parámetros, se recoge el tipo que retorna la función y se asigna al simbolo función
	simbolo_funcion.parList = Parametros() <tRETURN> tipo_return = Tipo_variable() <tIS> {simbolo_funcion.returnType = tipo_return.type;}
	(Declaracion() <tPC>)*
	(Procedimiento() | Funcion())*
	<tBEGIN>
	(instruccion = Instruccion_con_return(tipo_return.type, 1)
	{
		if (!return_valido) return_valido = instruccion;
	})+
	<tEND> <tPC>
	{
		if (!return_valido) System.out.println("AVISO: Es posible que la función no alcance ningún return");
		st.removeBlock();
	}
}


void Instr_iterativa_sin_return():
{
	Par tipo;
}
{
	<tWHILE> tipo = Expresion() <tLOOP>
	{sf.verificar_bool(tipo.primero);}
	(Instruccion_sin_return())+
	<tEND> <tLOOP>
}


void Instr_condicional_sin_return():
{
	Par tipo;
}
{
	<tIF> tipo = Expresion() <tTHEN>
	{sf.verificar_bool(tipo.primero);}
	(Instruccion_sin_return())+
	MasIF()
	<tEND> <tIF>
}


void MasIF():
{
	Par tipo;
}
{
	<tELSIF> tipo = Expresion() <tTHEN>
	{sf.verificar_bool(tipo.primero);}
	(Instruccion_sin_return())+
	MasIF()
	| <tELSE> (Instruccion_sin_return())+
	| {}
}


void Instr_iterativa_con_return(Symbol.Types tipo_a_retornar, int nivel):
{
	Par tipo;
}
{
	<tWHILE> tipo = Expresion() <tLOOP>
	{sf.verificar_bool(tipo.primero);}
	(Instruccion_con_return(tipo_a_retornar, nivel))+
	<tEND> <tLOOP>
}


void Instr_condicional_con_return(Symbol.Types tipo_a_retornar, int nivel):
{
	Par tipo;
}
{
	<tIF> tipo = Expresion() <tTHEN>
	{sf.verificar_bool(tipo.primero);}
	(Instruccion_con_return(tipo_a_retornar, nivel))+
	MasIF_return(tipo_a_retornar, nivel)
	<tEND> <tIF>
}


void MasIF_return(Symbol.Types tipo_a_retornar, int nivel):
{
	Par tipo;
}
{
	<tELSIF> tipo = Expresion() <tTHEN>
	{sf.verificar_bool(tipo.primero);}
	(Instruccion_con_return(tipo_a_retornar, nivel))+
	MasIF_return(tipo_a_retornar, nivel)
	| <tELSE> (Instruccion_con_return(tipo_a_retornar, nivel))+
	| {}
}
